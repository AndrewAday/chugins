//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

#include "FFTConvolver.h"
#include "TwoStageFFTConvolver.h"
#include "Utilities.h"

// general includes
#include <stdio.h>
#include <thread>
#include <limits.h>

// declaration of chugin constructor
CK_DLL_CTOR(convrev_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(convrev_dtor);

// example of getter/setter
CK_DLL_MFUN(convrev_setBlockSize);
CK_DLL_MFUN(convrev_getBlockSize);

// Set order of IR buffer
CK_DLL_MFUN(convrev_setOrder);
CK_DLL_MFUN(convrev_getOrder);

// populate individual IR sample values
CK_DLL_MFUN(convrev_setCoeff);
CK_DLL_MFUN(convrev_getCoeff);

// load entire buffer at once  (see fluidsynth for how to take in array arg)
// CK_DLL_MFUN(convrev_setIRBuffer);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(convrev_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT convrev_data_offset = 0;


/*
TODO
- store IR buffer as member variable
- buffer incoming samples in circular buffer
  - cpp circular buffer implementation?
  - https://en.wikipedia.org/wiki/Circular_buffer

- can I do multithreading in chugin?

#if defined(FFTCONVOLVER_USE_SSE)
    _mm_malloc(ptr) and _mm_free(ptr) for memory-aligned buffers
#else


Baby steps
1. get fft convolution working at all. Buffer whole input, convolve, and output.
  - this is the naive block conv described in paper
2. implement equivalent of FFTConvolveMono.ck with FFTConvolver, uniform partitions
3. search for existing implementations of Gardner's paper

*/

// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)


class ConvRev
{
public:
    // constructor
    ConvRev( t_CKFLOAT fs)
    {
        _SR = fs;
        _blocksize = 128;
        _order = 0;
        _ir_buffer = new float[0];
        _convolver = new fftconvolver::FFTConvolver();
        _tmp = 0;
    }

    ~ConvRev()
    {
        delete[] _ir_buffer;
        delete _convolver;
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
        return _ir_buffer[_tmp++ % _order];
        // return in;
    }

    // set parameter example
    t_CKFLOAT setBlockSize( t_CKFLOAT p )
    {
        _blocksize = p;
        return p;
    }

    // get parameter example
    t_CKFLOAT getBlockSize() { return _blocksize; }

    t_CKINT setOrder( t_CKINT m )
    {

        delete[] _ir_buffer;

        _ir_buffer = new float[m];

        for (int i = 0; i < m; i++)  {
            _ir_buffer[i] = 0.0;
        }

        _order = m;

        return _order;
    }

    t_CKINT getOrder() {
      std::thread thr(&ConvRev::test_thread_print, this);
      thr.join();
      return _order;
    }

    t_CKFLOAT setCoeff(t_CKINT idx, t_CKFLOAT val) {
      if (idx >= _order) {
        printf("illegal idx out of bounds, idx = %li on size %li\n", idx, _order);
        return val;
      }
      _ir_buffer[idx] = val;
      return val;
    }
    t_CKFLOAT getCoeff(t_CKINT idx) { return _ir_buffer[idx]; }

    void test_thread_print() { printf("thread print %li\n", _order); }

private:
    // instance data
    t_CKINT _blocksize;
    t_CKFLOAT _SR;
    t_CKINT _order;
    int _tmp;
    float *_ir_buffer;
    fftconvolver::FFTConvolver *_convolver;

};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( ConvRev )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "ConvRev");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "ConvRev", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, convrev_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, convrev_dtor);

    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, convrev_tick, NULL, 1, 1);

    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, convrev_setBlockSize, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, convrev_getBlockSize, "float", "param");


    QUERY->add_mfun(QUERY, convrev_setOrder, "int", "order");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, convrev_getOrder, "int", "order");


    QUERY->add_mfun(QUERY, convrev_setCoeff, "float", "coeff");
    QUERY->add_arg(QUERY, "int", "arg");
    QUERY->add_arg(QUERY, "float", "arg2");

    QUERY->add_mfun(QUERY, convrev_getCoeff, "float", "coeff");
    QUERY->add_arg(QUERY, "int", "arg");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    convrev_data_offset = QUERY->add_mvar(QUERY, "int", "@cr_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(convrev_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, convrev_data_offset) = 0;

    // instantiate our internal c++ class representation
    ConvRev * cr_obj = new ConvRev(API->vm->get_srate(API, SHRED));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, convrev_data_offset) = (t_CKINT) cr_obj;
}


// implementation for the destructor
CK_DLL_DTOR(convrev_dtor)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    // check it
    if( cr_obj )
    {
        // clean up
        delete cr_obj;
        OBJ_MEMBER_INT(SELF, convrev_data_offset) = 0;
        cr_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(convrev_tick)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);

    // invoke our tick function; store in the magical out variable
    if(cr_obj) *out = cr_obj->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(convrev_setBlockSize)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    // set the return value
    RETURN->v_float = cr_obj->setBlockSize(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(convrev_getBlockSize)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    // set the return value
    RETURN->v_float = cr_obj->getBlockSize();
}

CK_DLL_MFUN(convrev_setOrder)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    RETURN->v_int = cr_obj->setOrder(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(convrev_getOrder)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    RETURN->v_int = cr_obj->getOrder();
}


CK_DLL_MFUN(convrev_setCoeff)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    t_CKINT idx = GET_NEXT_INT(ARGS);
    t_CKFLOAT val = GET_NEXT_FLOAT(ARGS);
    RETURN->v_int = cr_obj->setCoeff(idx, val);
}

CK_DLL_MFUN(convrev_getCoeff)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    RETURN->v_int = cr_obj->getCoeff(GET_CK_INT(ARGS));
}
